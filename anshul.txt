diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..13cd6dd
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,23 @@
+{
+    "files.associations": {
+        "proc.h": "c",
+        "types.h": "c",
+        "x86.h": "c",
+        "defs.h": "c",
+        "date.h": "c",
+        "mmu.h": "c",
+        "memlayout.h": "c",
+        "param.h": "c",
+        "fcntl.h": "c",
+        "syscall.h": "c",
+        "signals.h": "c",
+        "limits": "c",
+        "spinlock.h": "c",
+        "fs.h": "c",
+        "user.h": "c",
+        "stat.h": "c",
+        "stdio.h": "c",
+        "signal.h": "c",
+        "sigset_t.h": "c"
+    }
+}
\ No newline at end of file
diff --git a/Makefile b/Makefile
index 09d790c..52729e9 100644
--- a/Makefile
+++ b/Makefile
@@ -27,6 +27,9 @@ OBJS = \
 	uart.o\
 	vectors.o\
 	vm.o\
+	syssignal.o\
+	signals.o\
+	
 
 # Cross-compiling (e.g., on Mac OS X)
 # TOOLPREFIX = i386-jos-elf
@@ -181,6 +184,8 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_trykill1\
+	_loop\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -248,7 +253,7 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
 # check in that version.
 
 EXTRA=\
-	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c signals.h\
 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
 	printf.c umalloc.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
diff --git a/defs.h b/defs.h
index 82fb982..58d09e7 100644
--- a/defs.h
+++ b/defs.h
@@ -9,6 +9,7 @@ struct spinlock;
 struct sleeplock;
 struct stat;
 struct superblock;
+struct sigset_t;
 
 // bio.c
 void            binit(void);
@@ -120,6 +121,10 @@ void            userinit(void);
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+int             kill1(int,int);
+int             signal(int, void(*)(int));
+int             pause(int*);
+int             sigprocmask(int, struct sigset_t*, struct sigset_t*);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
@@ -154,6 +159,7 @@ int             argptr(int, char**, int);
 int             argstr(int, char**);
 int             fetchint(uint, int*);
 int             fetchstr(uint, char**);
+int             argfun(int , void( **)(int), int );
 void            syscall(void);
 
 // timer.c
diff --git a/loop.c b/loop.c
new file mode 100644
index 0000000..28a0176
--- /dev/null
+++ b/loop.c
@@ -0,0 +1,14 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fs.h"
+
+int main(int argc , char* argv[]){
+    int a = getpid();
+    for(;;)
+    {
+        printf(1, "%d", a);
+        sleep(1);
+    }   
+ exit();
+}
\ No newline at end of file
diff --git a/param.h b/param.h
index a7e90ef..ba72883 100644
--- a/param.h
+++ b/param.h
@@ -11,4 +11,5 @@
 #define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
 #define FSSIZE       1000  // size of file system in blocks
+#define MAX_SIGNALS    30 //maximum number of signals that can be sent to a process
 
diff --git a/proc.c b/proc.c
index 806b1b1..377b54c 100644
--- a/proc.c
+++ b/proc.c
@@ -6,8 +6,10 @@
 #include "x86.h"
 #include "proc.h"
 #include "spinlock.h"
+#include "signals.h"
 
-struct {
+struct
+{
   struct spinlock lock;
   struct proc proc[NPROC];
 } ptable;
@@ -19,33 +21,34 @@ extern void forkret(void);
 extern void trapret(void);
 
 static void wakeup1(void *chan);
+extern int pause_chan;
 
-void
-pinit(void)
+void pinit(void)
 {
   initlock(&ptable.lock, "ptable");
 }
 
 // Must be called with interrupts disabled
-int
-cpuid() {
-  return mycpu()-cpus;
+int cpuid()
+{
+  return mycpu() - cpus;
 }
 
 // Must be called with interrupts disabled to avoid the caller being
 // rescheduled between reading lapicid and running through the loop.
-struct cpu*
+struct cpu *
 mycpu(void)
 {
   int apicid, i;
-  
-  if(readeflags()&FL_IF)
+
+  if (readeflags() & FL_IF)
     panic("mycpu called with interrupts enabled\n");
-  
+
   apicid = lapicid();
   // APIC IDs are not guaranteed to be contiguous. Maybe we should have
   // a reverse map, or reserve a register to store &cpus[i].
-  for (i = 0; i < ncpu; ++i) {
+  for (i = 0; i < ncpu; ++i)
+  {
     if (cpus[i].apicid == apicid)
       return &cpus[i];
   }
@@ -54,8 +57,9 @@ mycpu(void)
 
 // Disable interrupts so that we are not rescheduled
 // while reading proc from the cpu structure
-struct proc*
-myproc(void) {
+struct proc *
+myproc(void)
+{
   struct cpu *c;
   struct proc *p;
   pushcli();
@@ -65,12 +69,12 @@ myproc(void) {
   return p;
 }
 
-//PAGEBREAK: 32
-// Look in the process table for an UNUSED proc.
-// If found, change state to EMBRYO and initialize
-// state required to run in the kernel.
-// Otherwise return 0.
-static struct proc*
+// PAGEBREAK: 32
+//  Look in the process table for an UNUSED proc.
+//  If found, change state to EMBRYO and initialize
+//  state required to run in the kernel.
+//  Otherwise return 0.
+static struct proc *
 allocproc(void)
 {
   struct proc *p;
@@ -78,8 +82,8 @@ allocproc(void)
 
   acquire(&ptable.lock);
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == UNUSED)
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if (p->state == UNUSED)
       goto found;
 
   release(&ptable.lock);
@@ -92,7 +96,8 @@ found:
   release(&ptable.lock);
 
   // Allocate kernel stack.
-  if((p->kstack = kalloc()) == 0){
+  if ((p->kstack = kalloc()) == 0)
+  {
     p->state = UNUSED;
     return 0;
   }
@@ -100,33 +105,32 @@ found:
 
   // Leave room for trap frame.
   sp -= sizeof *p->tf;
-  p->tf = (struct trapframe*)sp;
+  p->tf = (struct trapframe *)sp;
 
   // Set up new context to start executing at forkret,
   // which returns to trapret.
   sp -= 4;
-  *(uint*)sp = (uint)trapret;
+  *(uint *)sp = (uint)trapret;
 
   sp -= sizeof *p->context;
-  p->context = (struct context*)sp;
+  p->context = (struct context *)sp;
   memset(p->context, 0, sizeof *p->context);
   p->context->eip = (uint)forkret;
 
   return p;
 }
 
-//PAGEBREAK: 32
-// Set up first user process.
-void
-userinit(void)
+// PAGEBREAK: 32
+//  Set up first user process.
+void userinit(void)
 {
   struct proc *p;
   extern char _binary_initcode_start[], _binary_initcode_size[];
 
   p = allocproc();
-  
+
   initproc = p;
-  if((p->pgdir = setupkvm()) == 0)
+  if ((p->pgdir = setupkvm()) == 0)
     panic("userinit: out of memory?");
   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
   p->sz = PGSIZE;
@@ -137,7 +141,7 @@ userinit(void)
   p->tf->ss = p->tf->ds;
   p->tf->eflags = FL_IF;
   p->tf->esp = PGSIZE;
-  p->tf->eip = 0;  // beginning of initcode.S
+  p->tf->eip = 0; // beginning of initcode.S
 
   safestrcpy(p->name, "initcode", sizeof(p->name));
   p->cwd = namei("/");
@@ -155,18 +159,20 @@ userinit(void)
 
 // Grow current process's memory by n bytes.
 // Return 0 on success, -1 on failure.
-int
-growproc(int n)
+int growproc(int n)
 {
   uint sz;
   struct proc *curproc = myproc();
 
   sz = curproc->sz;
-  if(n > 0){
-    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+  if (n > 0)
+  {
+    if ((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
       return -1;
-  } else if(n < 0){
-    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+  }
+  else if (n < 0)
+  {
+    if ((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
       return -1;
   }
   curproc->sz = sz;
@@ -177,20 +183,21 @@ growproc(int n)
 // Create a new process copying p as the parent.
 // Sets up stack to return as if from system call.
 // Caller must set state of returned proc to RUNNABLE.
-int
-fork(void)
+int fork(void)
 {
   int i, pid;
   struct proc *np;
   struct proc *curproc = myproc();
 
   // Allocate process.
-  if((np = allocproc()) == 0){
+  if ((np = allocproc()) == 0)
+  {
     return -1;
   }
 
   // Copy process state from proc.
-  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
+  if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0)
+  {
     kfree(np->kstack);
     np->kstack = 0;
     np->state = UNUSED;
@@ -203,8 +210,8 @@ fork(void)
   // Clear %eax so that fork returns 0 in the child.
   np->tf->eax = 0;
 
-  for(i = 0; i < NOFILE; i++)
-    if(curproc->ofile[i])
+  for (i = 0; i < NOFILE; i++)
+    if (curproc->ofile[i])
       np->ofile[i] = filedup(curproc->ofile[i]);
   np->cwd = idup(curproc->cwd);
 
@@ -224,19 +231,20 @@ fork(void)
 // Exit the current process.  Does not return.
 // An exited process remains in the zombie state
 // until its parent calls wait() to find out it exited.
-void
-exit(void)
+void exit(void)
 {
   struct proc *curproc = myproc();
   struct proc *p;
   int fd;
 
-  if(curproc == initproc)
+  if (curproc == initproc)
     panic("init exiting");
 
   // Close all open files.
-  for(fd = 0; fd < NOFILE; fd++){
-    if(curproc->ofile[fd]){
+  for (fd = 0; fd < NOFILE; fd++)
+  {
+    if (curproc->ofile[fd])
+    {
       fileclose(curproc->ofile[fd]);
       curproc->ofile[fd] = 0;
     }
@@ -253,10 +261,12 @@ exit(void)
   wakeup1(curproc->parent);
 
   // Pass abandoned children to init.
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->parent == curproc){
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->parent == curproc)
+    {
       p->parent = initproc;
-      if(p->state == ZOMBIE)
+      if (p->state == ZOMBIE)
         wakeup1(initproc);
     }
   }
@@ -269,22 +279,24 @@ exit(void)
 
 // Wait for a child process to exit and return its pid.
 // Return -1 if this process has no children.
-int
-wait(void)
+int wait(void)
 {
   struct proc *p;
   int havekids, pid;
   struct proc *curproc = myproc();
-  
+
   acquire(&ptable.lock);
-  for(;;){
+  for (;;)
+  {
     // Scan through table looking for exited children.
     havekids = 0;
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->parent != curproc)
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    {
+      if (p->parent != curproc)
         continue;
       havekids = 1;
-      if(p->state == ZOMBIE){
+      if (p->state == ZOMBIE)
+      {
         // Found one.
         pid = p->pid;
         kfree(p->kstack);
@@ -301,45 +313,72 @@ wait(void)
     }
 
     // No point waiting if we don't have any children.
-    if(!havekids || curproc->killed){
+    if (!havekids || curproc->killed)
+    {
       release(&ptable.lock);
       return -1;
     }
 
     // Wait for children to exit.  (See wakeup1 call in proc_exit.)
-    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+    sleep(curproc, &ptable.lock); // DOC: wait-sleep
   }
 }
 
-//PAGEBREAK: 42
-// Per-CPU process scheduler.
-// Each CPU calls scheduler() after setting itself up.
-// Scheduler never returns.  It loops, doing:
-//  - choose a process to run
-//  - swtch to start running that process
-//  - eventually that process transfers control
-//      via swtch back to the scheduler.
-void
-scheduler(void)
+// PAGEBREAK: 42
+//  Per-CPU process scheduler.
+//  Each CPU calls scheduler() after setting itself up.
+//  Scheduler never returns.  It loops, doing:
+//   - choose a process to run
+//   - swtch to start running that process
+//   - eventually that process transfers control
+//       via swtch back to the scheduler.
+void scheduler(void)
 {
   struct proc *p;
   struct cpu *c = mycpu();
   c->proc = 0;
-  
-  for(;;){
+
+  for (;;)
+  {
     // Enable interrupts on this processor.
     sti();
 
     // Loop over process table looking for process to run.
     acquire(&ptable.lock);
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->state != RUNNABLE)
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    {
+      if (p->state != RUNNABLE)
         continue;
 
       // Switch to chosen process.  It is the process's job
       // to release ptable.lock and then reacquire it
       // before jumping back to us.
       c->proc = p;
+
+      for(int i = 0; i < MAX_SIGNALS; i++){
+        if(c->proc->pendingSignals[i] == 1 && c->proc->blockedSignals[i] == 0){
+          p->chan = 0;
+          if(c->proc->hasUserHandler[i] == 0){
+            c->proc->pendingSignals[i] = 0;
+            doDefaultSignal(i);
+          }
+        }
+      }
+
+      for (int i = 0; i < MAX_SIGNALS; i++)
+      {
+        if (c->proc->pendingSignals[i] == 1 && c->proc->blockedSignals[i] == 0)
+        {
+          p->chan = 0;
+          c->proc->pendingSignals[i] = 0;
+          if (c->proc->hasUserHandler[i] == 1)
+          {
+            p->tf->eip = (uint)c->proc->signalHandlers[i];
+            break;
+          }
+        }
+      }
+      
       switchuvm(p);
       p->state = RUNNING;
 
@@ -351,7 +390,6 @@ scheduler(void)
       c->proc = 0;
     }
     release(&ptable.lock);
-
   }
 }
 
@@ -362,19 +400,18 @@ scheduler(void)
 // be proc->intena and proc->ncli, but that would
 // break in the few places where a lock is held but
 // there's no process.
-void
-sched(void)
+void sched(void)
 {
   int intena;
   struct proc *p = myproc();
 
-  if(!holding(&ptable.lock))
+  if (!holding(&ptable.lock))
     panic("sched ptable.lock");
-  if(mycpu()->ncli != 1)
+  if (mycpu()->ncli != 1)
     panic("sched locks");
-  if(p->state == RUNNING)
+  if (p->state == RUNNING)
     panic("sched running");
-  if(readeflags()&FL_IF)
+  if (readeflags() & FL_IF)
     panic("sched interruptible");
   intena = mycpu()->intena;
   swtch(&p->context, mycpu()->scheduler);
@@ -382,25 +419,25 @@ sched(void)
 }
 
 // Give up the CPU for one scheduling round.
-void
-yield(void)
+void yield(void)
 {
-  acquire(&ptable.lock);  //DOC: yieldlock
+  acquire(&ptable.lock); // DOC: yieldlock
   myproc()->state = RUNNABLE;
   sched();
+  // TODO : Run user defined signal handler
   release(&ptable.lock);
 }
 
 // A fork child's very first scheduling by scheduler()
 // will swtch here.  "Return" to user space.
-void
-forkret(void)
+void forkret(void)
 {
   static int first = 1;
   // Still holding ptable.lock from scheduler.
   release(&ptable.lock);
 
-  if (first) {
+  if (first)
+  {
     // Some initialization functions must be run in the context
     // of a regular process (e.g., they call sleep), and thus cannot
     // be run from main().
@@ -414,15 +451,14 @@ forkret(void)
 
 // Atomically release lock and sleep on chan.
 // Reacquires lock when awakened.
-void
-sleep(void *chan, struct spinlock *lk)
+void sleep(void *chan, struct spinlock *lk)
 {
   struct proc *p = myproc();
-  
-  if(p == 0)
+
+  if (p == 0)
     panic("sleep");
 
-  if(lk == 0)
+  if (lk == 0)
     panic("sleep without lk");
 
   // Must acquire ptable.lock in order to
@@ -431,8 +467,9 @@ sleep(void *chan, struct spinlock *lk)
   // guaranteed that we won't miss any wakeup
   // (wakeup runs with ptable.lock locked),
   // so it's okay to release lk.
-  if(lk != &ptable.lock){  //DOC: sleeplock0
-    acquire(&ptable.lock);  //DOC: sleeplock1
+  if (lk != &ptable.lock)
+  {                        // DOC: sleeplock0
+    acquire(&ptable.lock); // DOC: sleeplock1
     release(lk);
   }
   // Go to sleep.
@@ -442,31 +479,32 @@ sleep(void *chan, struct spinlock *lk)
   sched();
 
   // Tidy up.
-  p->chan = 0;
+  if(p->chan != &pause_chan)
+    p->chan = 0;
 
   // Reacquire original lock.
-  if(lk != &ptable.lock){  //DOC: sleeplock2
+  if (lk != &ptable.lock)
+  { // DOC: sleeplock2
     release(&ptable.lock);
     acquire(lk);
   }
 }
 
-//PAGEBREAK!
-// Wake up all processes sleeping on chan.
-// The ptable lock must be held.
+// PAGEBREAK!
+//  Wake up all processes sleeping on chan.
+//  The ptable lock must be held.
 static void
 wakeup1(void *chan)
 {
   struct proc *p;
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == SLEEPING && p->chan == chan)
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if (p->state == SLEEPING && p->chan == chan)
       p->state = RUNNABLE;
 }
 
 // Wake up all processes sleeping on chan.
-void
-wakeup(void *chan)
+void wakeup(void *chan)
 {
   acquire(&ptable.lock);
   wakeup1(chan);
@@ -476,17 +514,69 @@ wakeup(void *chan)
 // Kill the process with the given pid.
 // Process won't exit until it returns
 // to user space (see trap in trap.c).
-int
-kill(int pid)
+int kill(int pid)
 {
   struct proc *p;
 
   acquire(&ptable.lock);
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->pid == pid){
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->pid == pid)
+    {
       p->killed = 1;
       // Wake process from sleep if necessary.
-      if(p->state == SLEEPING)
+      if (p->state == SLEEPING)
+        p->state = RUNNABLE;
+      release(&ptable.lock);
+      return 0;
+    }
+  }
+  release(&ptable.lock);
+  return -1;
+}
+
+void dh_sigkill(int signo)
+{
+  cprintf("into default sigkill\n");
+  struct proc *curproc = myproc();
+  curproc->killed = 1;
+}
+
+void dh_sigstop(int signo)
+{
+}
+
+void dh_sigint(int signo)
+{
+}
+
+int pause(int *pause_chan)
+{
+  struct proc *curproc = myproc();
+  curproc->chan = pause_chan;
+  curproc->state = SLEEPING;
+  acquire(&ptable.lock);
+
+  while (curproc->chan == pause_chan)
+    sleep(&pause_chan, &ptable.lock);
+
+  release(&ptable.lock);
+  return 0;
+}
+
+// send the process with given pid signal signum
+int kill1(int pid, int signum)
+{
+  struct proc *p;
+
+  acquire(&ptable.lock);
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->pid == pid)
+    {
+      p->pendingSignals[signum] = 1; // adding signals to pending list
+      // Wake process from sleep if necessary.
+      if (p->state == SLEEPING)
         p->state = RUNNABLE;
       release(&ptable.lock);
       return 0;
@@ -496,37 +586,80 @@ kill(int pid)
   return -1;
 }
 
-//PAGEBREAK: 36
-// Print a process listing to console.  For debugging.
-// Runs when user types ^P on console.
-// No lock to avoid wedging a stuck machine further.
-void
-procdump(void)
+// int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact ){
+
+// }
+
+int signal(int signum, signalHandler fn)
+{
+  struct proc *curproc = myproc();
+  curproc->hasUserHandler[signum] = 1;
+  curproc->signalHandlers[signum] = fn;
+  cprintf("funciton pointer inside singnal %x", fn);
+  return 0;
+}
+
+int sigprocmask(int how, struct sigset_t *set, struct sigset_t *oldset){
+  struct proc *curproc = myproc();
+  for(int i = 0; i < MAX_SIGNALS; i++){
+    if(set->mask[i] == 1){
+      oldset->mask[i] = 1;
+    }
+    else{
+      oldset->mask[i] = 0;
+    }
+  }
+  if(how == SIG_BLOCK){
+    for(int i = 0; i < MAX_SIGNALS; i++){
+      if(set->mask[i] == 1){
+        curproc->blockedSignals[i] = 1;
+      }
+    }
+  }
+  else if(how == SIG_UNBLOCK){
+    for(int i = 0; i < MAX_SIGNALS; i++){
+      if(set->mask[i] == 1){
+        curproc->blockedSignals[i] = 0;
+      }
+    }
+  }
+  else if(how == SIG_SETMASK){
+    //TODO : behaviour of SIG_SETMASK
+  }
+  return 0;
+}
+
+// PAGEBREAK: 36
+//  Print a process listing to console.  For debugging.
+//  Runs when user types ^P on console.
+//  No lock to avoid wedging a stuck machine further.
+void procdump(void)
 {
   static char *states[] = {
-  [UNUSED]    "unused",
-  [EMBRYO]    "embryo",
-  [SLEEPING]  "sleep ",
-  [RUNNABLE]  "runble",
-  [RUNNING]   "run   ",
-  [ZOMBIE]    "zombie"
-  };
+      [UNUSED] "unused",
+      [EMBRYO] "embryo",
+      [SLEEPING] "sleep ",
+      [RUNNABLE] "runble",
+      [RUNNING] "run   ",
+      [ZOMBIE] "zombie"};
   int i;
   struct proc *p;
   char *state;
   uint pc[10];
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->state == UNUSED)
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->state == UNUSED)
       continue;
-    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+    if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
       state = states[p->state];
     else
       state = "???";
     cprintf("%d %s %s", p->pid, state, p->name);
-    if(p->state == SLEEPING){
-      getcallerpcs((uint*)p->context->ebp+2, pc);
-      for(i=0; i<10 && pc[i] != 0; i++)
+    if (p->state == SLEEPING)
+    {
+      getcallerpcs((uint *)p->context->ebp + 2, pc);
+      for (i = 0; i < 10 && pc[i] != 0; i++)
         cprintf(" %p", pc[i]);
     }
     cprintf("\n");
diff --git a/proc.h b/proc.h
index 1647114..f5d0aa3 100644
--- a/proc.h
+++ b/proc.h
@@ -1,30 +1,32 @@
 // Per-CPU state
-struct cpu {
-  uchar apicid;                // Local APIC ID
-  struct context *scheduler;   // swtch() here to enter scheduler
-  struct taskstate ts;         // Used by x86 to find stack for interrupt
-  struct segdesc gdt[NSEGS];   // x86 global descriptor table
-  volatile uint started;       // Has the CPU started?
-  int ncli;                    // Depth of pushcli nesting.
-  int intena;                  // Were interrupts enabled before pushcli?
-  struct proc *proc;           // The process running on this cpu or null
+struct cpu
+{
+  uchar apicid;              // Local APIC ID
+  struct context *scheduler; // swtch() here to enter scheduler
+  struct taskstate ts;       // Used by x86 to find stack for interrupt
+  struct segdesc gdt[NSEGS]; // x86 global descriptor table
+  volatile uint started;     // Has the CPU started?
+  int ncli;                  // Depth of pushcli nesting.
+  int intena;                // Were interrupts enabled before pushcli?
+  struct proc *proc;         // The process running on this cpu or null
 };
 
 extern struct cpu cpus[NCPU];
 extern int ncpu;
 
-//PAGEBREAK: 17
-// Saved registers for kernel context switches.
-// Don't need to save all the segment registers (%cs, etc),
-// because they are constant across kernel contexts.
-// Don't need to save %eax, %ecx, %edx, because the
-// x86 convention is that the caller has saved them.
-// Contexts are stored at the bottom of the stack they
-// describe; the stack pointer is the address of the context.
-// The layout of the context matches the layout of the stack in swtch.S
-// at the "Switch stacks" comment. Switch doesn't save eip explicitly,
-// but it is on the stack and allocproc() manipulates it.
-struct context {
+// PAGEBREAK: 17
+//  Saved registers for kernel context switches.
+//  Don't need to save all the segment registers (%cs, etc),
+//  because they are constant across kernel contexts.
+//  Don't need to save %eax, %ecx, %edx, because the
+//  x86 convention is that the caller has saved them.
+//  Contexts are stored at the bottom of the stack they
+//  describe; the stack pointer is the address of the context.
+//  The layout of the context matches the layout of the stack in swtch.S
+//  at the "Switch stacks" comment. Switch doesn't save eip explicitly,
+//  but it is on the stack and allocproc() manipulates it.
+struct context
+{
   uint edi;
   uint esi;
   uint ebx;
@@ -32,23 +34,36 @@ struct context {
   uint eip;
 };
 
-enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
+enum procstate
+{
+  UNUSED,
+  EMBRYO,
+  SLEEPING,
+  RUNNABLE,
+  RUNNING,
+  ZOMBIE
+};
 
 // Per-process state
-struct proc {
-  uint sz;                     // Size of process memory (bytes)
-  pde_t* pgdir;                // Page table
-  char *kstack;                // Bottom of kernel stack for this process
-  enum procstate state;        // Process state
-  int pid;                     // Process ID
-  struct proc *parent;         // Parent process
-  struct trapframe *tf;        // Trap frame for current syscall
-  struct context *context;     // swtch() here to run process
-  void *chan;                  // If non-zero, sleeping on chan
-  int killed;                  // If non-zero, have been killed
-  struct file *ofile[NOFILE];  // Open files
-  struct inode *cwd;           // Current directory
-  char name[16];               // Process name (debugging)
+struct proc
+{
+  uint sz;                    // Size of process memory (bytes)
+  pde_t *pgdir;               // Page table
+  char *kstack;               // Bottom of kernel stack for this process
+  enum procstate state;       // Process state
+  int pid;                    // Process ID
+  struct proc *parent;        // Parent process
+  struct trapframe *tf;       // Trap frame for current syscall
+  struct context *context;    // swtch() here to run process
+  void *chan;                 // If non-zero, sleeping on chan
+  int killed;                 // If non-zero, have been killed
+  struct file *ofile[NOFILE]; // Open files
+  struct inode *cwd;          // Current directory
+  char name[16];              // Process name (debugging)
+  int pendingSignals[MAX_SIGNALS]; //signals to be delivered
+  int blockedSignals[MAX_SIGNALS]; // list of blocked signals
+  int hasUserHandler[MAX_SIGNALS]; //checks whether user has set handler
+  void (*signalHandlers[MAX_SIGNALS])(int); //array for signal handler function pointers
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/signals.c b/signals.c
new file mode 100644
index 0000000..645607c
--- /dev/null
+++ b/signals.c
@@ -0,0 +1,30 @@
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "x86.h"
+#include "proc.h"
+#include "spinlock.h"
+#include "signals.h"
+
+extern void dh_sigkill(int);
+extern void dh_sigstop(int);
+extern void dh_sigint(int);
+
+static void(*defaultHandlers[])(int) = {
+    [SIGKILL] dh_sigkill,
+    [SIGSTOP] dh_sigstop,
+    [SIGINT]  dh_sigint,
+};
+
+//function that runs default signal handler in kernel stack 
+int doDefaultSignal(int signo){
+  defaultHandlers[signo](signo);
+  return 0;
+}
+
+//funtion defined to run user handlers in user stack
+int doSignal(int signo){
+  return 0;
+}
\ No newline at end of file
diff --git a/signals.h b/signals.h
new file mode 100644
index 0000000..ed46578
--- /dev/null
+++ b/signals.h
@@ -0,0 +1,29 @@
+#include"param.h"
+#define SIGKILL 1
+#define SIGSTOP 2
+#define SIGINT 3
+
+#define SIG_BLOCK 100
+#define SIG_UNBLOCK 101
+#define SIG_SETMASK 102
+
+int doDefaultSignal(int signo);
+int doSignal(int signo);
+
+typedef void(*signalHandler)(int);
+
+struct sigset_t{
+    unsigned long int mask[MAX_SIGNALS]; 
+};
+
+struct sigaction
+{
+    void (*sa_handler)(int);
+    void (*sa_sigaction)(int, int *, void *);
+    int sa_mask;
+    int sa_flags;
+    void (*sa_restorer)(void);
+};  
+
+
+
diff --git a/syscall.c b/syscall.c
index ee85261..c56a32d 100644
--- a/syscall.c
+++ b/syscall.c
@@ -69,6 +69,20 @@ argptr(int n, char **pp, int size)
   return 0;
 }
 
+int
+argfun(int n, void( **pp)(int), int size)
+{
+  int i;
+  struct proc *curproc = myproc();
+ 
+  if(argint(n, &i) < 0)
+    return -1;
+  if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
+    return -1;
+  *pp = (void(*)(int))i;
+  return 0;
+}
+
 // Fetch the nth word-sized system call argument as a string pointer.
 // Check that the pointer is valid and the string is nul-terminated.
 // (There is no shared writable memory, so the string can't change
@@ -103,6 +117,10 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_kill1(void);
+extern int sys_signal(void);
+extern int sys_pause(void);
+extern int sys_sigprocmask(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +144,11 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_kill1]   sys_kill1,
+[SYS_signal]  sys_signal,
+[SYS_pause]   sys_pause,
+[SYS_sigprocmask] sys_sigprocmask,
+
 };
 
 void
diff --git a/syscall.h b/syscall.h
index bc5f356..b61bb31 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,8 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_kill1  22
+#define SYS_sigaction    23
+#define SYS_pause        24
+#define SYS_signal       25
+#define SYS_sigprocmask  26
diff --git a/syssignal.c b/syssignal.c
new file mode 100644
index 0000000..3e1343b
--- /dev/null
+++ b/syssignal.c
@@ -0,0 +1,43 @@
+#include "types.h"
+#include "x86.h"
+#include "defs.h"
+#include "date.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "proc.h"
+#include "signals.h"
+
+extern int pause_chan;
+
+int sys_kill1(void){
+
+  int pid, signum;
+  if(argint(0, &pid) < 0 || argint(1, &signum) < 0)
+    return -1;
+  return kill1(pid, signum);
+}
+
+int sys_pause(void){
+  return pause(&pause_chan);
+}
+
+int sys_signal(void){
+  int signo;
+  void (*fn)(int);
+  if(argint(0, &signo) < 0 || argfun(1, &fn, sizeof(fn)) < 0){
+    return -1;
+  }
+  return signal(signo, fn);
+}
+
+int sys_sigprocmask(void){
+  int how;
+  struct sigset_t* set;
+  struct sigset_t* oldset;
+  if(argint(0, &how) < 0 || argptr(1, (void*)&set, sizeof(set)) < 0  || argptr(2, (void*)&oldset, sizeof(oldset)) < 0 ){
+    return -1;
+  }
+  return sigprocmask(how, set, oldset);
+}
+
diff --git a/trap.c b/trap.c
index 41c66eb..518aa4c 100644
--- a/trap.c
+++ b/trap.c
@@ -13,6 +13,7 @@ struct gatedesc idt[256];
 extern uint vectors[];  // in vectors.S: array of 256 entry pointers
 struct spinlock tickslock;
 uint ticks;
+uint pause_chan;
 
 void
 tvinit(void)
@@ -52,6 +53,7 @@ trap(struct trapframe *tf)
       acquire(&tickslock);
       ticks++;
       wakeup(&ticks);
+      wakeup(&pause_chan);
       release(&tickslock);
     }
     lapiceoi();
diff --git a/trykill1.c b/trykill1.c
new file mode 100644
index 0000000..de8750b
--- /dev/null
+++ b/trykill1.c
@@ -0,0 +1,69 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fs.h"
+#include "signals.h"
+
+void print(int signo){
+    printf(1, "inside user\n");
+}
+void temp(int signo){
+    // printf(1, "inside user defined signal handler\n");
+    for(int i = 1000; i < 1010 ; i++){
+        printf(1, "inides user handler %d \n", i);
+    }
+    // print(signo);
+    // exit();
+}
+void temp2(int signo){
+    
+}
+
+int main(int argc , char* argv[]){
+    int a = getpid();
+
+    // struct sigset_t mask;
+    // struct sigset_t oldmask;
+
+    // sigprocmask(SIG_BLOCK, &mask, &oldmask);
+    // printf(1, "printing pid in user land %d\n", a);
+
+    // signal(SIGKILL, &temp); 
+
+    // printf(1, "funciton call adddress %x \n", &temp);
+    // printf(1, "funciton call adddress %x \n", &temp2);
+    // printf(1, "funciton call adddress %x \n", &print);
+
+    // for(int  i =0; i < 100; i++){
+    //     printf(1, "%d \n", i);
+    // }
+
+    // kill1(a, SIGKILL);
+    
+    // for(int i  = 200; i < 300; i++ ){
+    //     printf(1, "%d \n", i);
+    // }
+
+    int b = fork();
+    if(b == 0){
+        for(int i = 400; i < 500; i++){
+            printf(1, "%d \n", i);
+        }
+            sleep(1);
+            printf(1, "i m child running\n");
+            kill1(a, SIGKILL);
+
+        for(int i = 100; i < 110 ; i++){
+            printf(1, "%d \n", i);
+        }
+    }
+    else{
+        pause();
+        for(int i = 0; i < 1000; i++){
+            printf(1, "%d \n", i);
+        }
+        // kill1(b,SIGKILL);
+        
+    }
+    exit();
+}
\ No newline at end of file
diff --git a/ulib.c b/ulib.c
index 8e1e1a2..420e82c 100644
--- a/ulib.c
+++ b/ulib.c
@@ -3,6 +3,7 @@
 #include "fcntl.h"
 #include "user.h"
 #include "x86.h"
+#include "signals.h"
 
 char*
 strcpy(char *s, const char *t)
@@ -104,3 +105,17 @@ memmove(void *vdst, const void *vsrc, int n)
     *dst++ = *src++;
   return vdst;
 }
+
+void
+sigemptyset(struct sigset_t* mask){
+  for(int i  = 0; i< MAX_SIGNALS ; i++){
+    mask->mask[i] = 0;
+  }
+  return;
+}
+
+void 
+sigaddset(struct sigset_t* mask, int signum){
+  mask->mask[signum] = 1;
+  return;
+}
\ No newline at end of file
diff --git a/user.h b/user.h
index 4f99c52..3129bdd 100644
--- a/user.h
+++ b/user.h
@@ -1,5 +1,6 @@
 struct stat;
 struct rtcdate;
+struct sigset_t;
 
 // system calls
 int fork(void);
@@ -23,6 +24,10 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int kill1(int,int);
+int signal(int,void(*)(int));
+int pause(void);
+int sigprocmask(int, struct sigset_t*, struct sigset_t*);
 
 // ulib.c
 int stat(const char*, struct stat*);
@@ -37,3 +42,5 @@ void* memset(void*, int, uint);
 void* malloc(uint);
 void free(void*);
 int atoi(const char*);
+
+// 
diff --git a/usys.S b/usys.S
index 8bfd8a1..4bed5cc 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,8 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(kill1)
+SYSCALL(signal)
+SYSCALL(pause)
+SYSCALL(sigprocmask)
+
diff --git a/x86.h b/x86.h
index 07312a5..9a25ee6 100644
--- a/x86.h
+++ b/x86.h
@@ -154,7 +154,7 @@ struct trapframe {
   uint ebp;
   uint oesp;      // useless & ignored
   uint ebx;
-  uint edx;
+  uint edx; 
   uint ecx;
   uint eax;
 
